import os
import copy
import torch
import torch.utils.data as data
import json
import cv2
import random


def transformImgToTensor(img):
    """

    :param img: numpy.ndarray  (generated by cv2.imread(), in format (H,W,C))
    :return: img:torch.Tensor (in format (C,H,W))
    """

    img = img.transpose(2, 0, 1)
    img = torch.from_numpy(img)
    img = img.float() / 255
    return img


class PatchInFrame(object):
    """
    Base is the basic patch class
    used for dumping into json file
    """
    def __init__(self, type, pos):
        self.type = type    # ball number, -1 for negative sample. type: int
        self.pos = copy.copy(pos)    # left up corner. type: tuple

    def __str__(self):
        return 'class: %s, coord: %s' % (self.type, self.pos)

    def dump(self):
        return self.__dict__


class PoolDataset(data.Dataset):
    def __init__(self, img_path, label_path):

        self.length = len([name for name in os.listdir(img_path) if os.path.isfile(os.path.join(img_path, name))])
        self.img_path = img_path
        self.label_path = label_path

    def __getitem__(self, index):
        name = 'annotation.json'
        dict_path = os.path.join(self.label_path, name)
        f = open(dict_path, 'r')
        json_string = f.read()
        f.close()
        dict_all = json.loads(json_string)
        self.length = dict_all['frame_number']

        dict_all_change = {}
        for image_id, image_label in dict_all['frame_dict'].items():
            # print(image_id, image_label)
            dict_all_change[image_id] = image_label

        image_number = list(dict_all['frame_dict'].keys())[index]  # 单局编号
        label = dict_all_change[image_number]

        img = cv2.imread(os.path.join(self.img_path, image_number + '.jpg'))  # 对应图像
        label = torch.Tensor([label])
        img_tensor = transformImgToTensor(img)

        return img_tensor, label

    def __len__(self):
        return self.length


def generate_train_val_sampler(total_train_size, train_ratio):
    """
    in pytorch, use sampler class in dataloader to generater trainset and valset
    this function return two sampler, train_sampler and val_sampler

    :param total_train_size: int. trainset and valset is splited from the total trainset.
            this parameter is the size of the total trainset
    :param train_ratio: ratio of the train set size in total train size. e.g., if
            train_ratio is 0.8, will generate 4/5 trainset, 1/5 valset of total trainset
    :return:
    """
    random.seed(123)  # CAUTION!!!  this line is just for developing

    indices = list(range(total_train_size))
    random.shuffle(indices)
    train_indices = indices[:int(total_train_size * train_ratio)]
    val_indices = indices[int(total_train_size * train_ratio):]

    train_sampler = data.sampler.SubsetRandomSampler(train_indices)
    val_sampler = data.sampler.SubsetRandomSampler(val_indices)

    return train_sampler, val_sampler


label_path = 'data/train/label'  # 标记路径
name = 'annotation.json'
path = os.path.join(label_path, name)

img_path = 'data/train/images'  # 图像路径

if __name__ == '__main__':

    trainset = PoolDataset(img_path, label_path)

    for img, label in trainset:
        print(label)
        pass


